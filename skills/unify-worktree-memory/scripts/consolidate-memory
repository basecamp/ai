#!/usr/bin/env bash
#
# One-time migration: consolidate Claude Code memory across git worktrees.
#
# For each repo under WORKTREE_ROOT, merges all worktree MEMORY.md files into
# the base repo's memory dir, copies topic files, and replaces worktree
# memory dirs with symlinks to the base.
#
set -euo pipefail

CLAUDE_PROJECTS="$HOME/.claude/projects"
WORKTREE_ROOT="$HOME/.worktrees"  # <-- customize this
DRY_RUN=false

if [[ "${1:-}" == "--dry-run" ]]; then
  DRY_RUN=true
  echo "=== DRY RUN ==="
  echo
fi

# Encode a filesystem path the way Claude Code does:
# /Users/you/Work/foo -> -Users-you-Work-foo
# Replaces / and . with -
encode_path() {
  echo "$1" | sed 's|/|-|g; s|\.|-|g'
}

# Collect all repo names for prefix disambiguation
repo_names=()
for repo_dir in "$WORKTREE_ROOT"/*/; do
  repo_names+=("$(basename "$repo_dir")")
done

merged=0
symlinked=0
skipped=0

process_worktree_memory() {
  local wt_project_dir="$1"
  local wt_memory="$wt_project_dir/memory"
  local wt_name="$2"
  local branch_hint="$3"
  local base_memory="$4"

  # Already a symlink — skip
  if [[ -L "$wt_memory" ]]; then
    echo "  ALREADY LINKED: $wt_name"
    ((skipped++)) || true
    return
  fi

  # No memory dir — just create the symlink
  if [[ ! -d "$wt_memory" ]]; then
    if [[ "$DRY_RUN" == false ]]; then
      ln -s "$base_memory" "$wt_memory"
    fi
    echo "  LINKED (empty): $wt_name"
    ((symlinked++)) || true
    return
  fi

  # Has memory dir with content — merge then symlink
  if [[ -f "$wt_memory/MEMORY.md" ]]; then
    if [[ "$DRY_RUN" == false ]]; then
      {
        echo ""
        echo "## From worktree: $branch_hint"
        echo ""
        cat "$wt_memory/MEMORY.md"
      } >> "$base_memory/MEMORY.md"
    fi
    echo "  MERGED MEMORY.md: $wt_name ($branch_hint)"
    ((merged++)) || true
  fi

  # Copy topic files (rename on conflict to avoid data loss)
  while IFS= read -r topic_file; do
    fname=$(basename "$topic_file")
    [[ "$fname" == "MEMORY.md" ]] && continue
    if [[ -f "$base_memory/$fname" ]]; then
      dest="${fname%.*}-${branch_hint}.${fname##*.}"
      if [[ "$DRY_RUN" == false ]]; then
        cp "$topic_file" "$base_memory/$dest"
      fi
      echo "  COPIED topic (renamed): $fname -> $dest"
    else
      if [[ "$DRY_RUN" == false ]]; then
        cp "$topic_file" "$base_memory/$fname"
      fi
      echo "  COPIED topic: $fname"
    fi
  done < <(find "$wt_memory" -maxdepth 1 -type f 2>/dev/null)

  # Replace with symlink
  if [[ "$DRY_RUN" == false ]]; then
    rm -rf "$wt_memory"
    ln -s "$base_memory" "$wt_memory"
  fi
  echo "  LINKED: $wt_name"
  ((symlinked++)) || true
}

for repo_dir in "$WORKTREE_ROOT"/*/; do
  repo_name=$(basename "$repo_dir")

  # Find any worktree with a .git file to resolve the base repo path
  base_repo=""
  while IFS= read -r git_file; do
    gitdir_line=$(cat "$git_file")
    base_repo=$(echo "$gitdir_line" | sed 's|^gitdir: ||; s|/\.git/worktrees/.*||')
    break
  done < <(find "$repo_dir" -name ".git" -type f -maxdepth 4 2>/dev/null)

  if [[ -z "$base_repo" ]]; then
    echo "SKIP $repo_name: no worktrees with .git file found"
    ((skipped++)) || true
    continue
  fi

  base_project_dir="$CLAUDE_PROJECTS/$(encode_path "$base_repo")"
  base_memory="$base_project_dir/memory"

  echo "--- $repo_name ---"
  echo "  base repo: $base_repo"

  if [[ "$DRY_RUN" == false ]]; then
    mkdir -p "$base_memory"
  fi

  # Phase 1: Process worktrees that still exist on disk (authoritative)
  while IFS= read -r git_file; do
    wt_path=$(dirname "$git_file")
    wt_encoded="$(encode_path "$wt_path")"
    wt_project_dir="$CLAUDE_PROJECTS/$wt_encoded"

    [[ -d "$wt_project_dir" ]] || continue

    process_worktree_memory "$wt_project_dir" "$wt_encoded" "$(basename "$wt_path")" "$base_memory"

  done < <(find "$repo_dir" -name ".git" -type f -maxdepth 4 2>/dev/null)

  # Phase 2: Handle orphaned Claude project dirs (worktrees deleted from disk)
  encoded_wt_root="$(encode_path "$WORKTREE_ROOT/$repo_name")"
  for wt_project_dir in "$CLAUDE_PROJECTS/$encoded_wt_root"-*/; do
    [[ -d "$wt_project_dir" ]] || continue
    wt_name=$(basename "$wt_project_dir")

    # Skip if already handled (already a symlink from phase 1)
    if [[ -L "$wt_project_dir/memory" ]]; then
      continue
    fi

    # Disambiguate: skip if a MORE SPECIFIC (longer) repo name prefix also matches.
    # e.g., for repo "my-app" with prefix "...-my-app-", skip "...-my-app-api-design"
    # because repo "my-app-api" owns that one. Only consider repos whose name
    # is strictly longer (more specific) than the current repo.
    claimed_by_longer=false
    for other_repo in "${repo_names[@]}"; do
      [[ "$other_repo" == "$repo_name" ]] && continue
      [[ ${#other_repo} -le ${#repo_name} ]] && continue
      other_prefix="$(encode_path "$WORKTREE_ROOT/$other_repo")"
      if [[ "$wt_name" == "$other_prefix"-* ]]; then
        claimed_by_longer=true
        break
      fi
    done
    if [[ "$claimed_by_longer" == true ]]; then
      continue
    fi

    branch_hint=$(echo "$wt_name" | sed "s|^${encoded_wt_root}-||")
    process_worktree_memory "$wt_project_dir" "$wt_name" "$branch_hint" "$base_memory"
  done

  echo
done

echo "=== Summary ==="
echo "  Merged MEMORY.md files: $merged"
echo "  Symlinks created: $symlinked"
echo "  Skipped: $skipped"

if [[ "$DRY_RUN" == true ]]; then
  echo
  echo "Re-run without --dry-run to apply changes."
fi
